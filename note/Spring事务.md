###                                Spring事务



#### 1. 事务的特性（ACID)

**原子性(Atomicity)** : 事务要么全部成功要么全部失败不会存在其他情况，假如程序运行出现错误那么就会回滚，保持事务开始之前的状态。

**一致性(Consistency)**: 是指操作事务前和操作后，**数据满足完整性约束**,数据库保持一致性状态。如：用户A账户余额为1000用户B余额为500,用户A给用户B转了200那么用户A的余额为800用户B余额为700

**隔离性(Isolation)**: 在并发程序中会有多个事务,每个事务只运行在自己的范围内每个事务不会互相干扰。

**持久性(Durability)**:事务处理结束，数据就不会在改变。

**InnoDB引擎通过什么保证事务的四个特性？**

* 持久性是通过 **redo log(重做日志)** 来保证；

* 原子性是通过 **undo log（回滚日志)**来保证；

* 隔离性是通过 **MVCC（多版本并发控制)** 或锁机制来保证的；

* 一致性则是通过持久性+原子性+隔离性来保证；

  

#### 2.并发事务会产生的问题

 **脏读**: 一个事务读取了另一个事务无提交但更新后的数据

 **不可重复读**: 在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。

  **幻读**: 在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。

**严重性排序**: 脏读 > 不可重复读 > 幻读

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

- **读未提交（read uncommitted）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（read committed）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（repeatable read）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（serializable）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

- 在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；
- 在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；
- 在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；
- 在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。

不同的数据库厂商对 SQL 标准中规定的 4 种隔离级别的支持不一样，有的数据库只实现了其中几种隔离级别，**我们讨论的 MySQL 虽然支持 4 种隔离级别，但是与SQL 标准中规定的各级隔离级别允许发生的现象却有些出入**。

MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。